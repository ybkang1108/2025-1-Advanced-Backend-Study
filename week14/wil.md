# Read, Write, and Space Amplification

### 읽기 증폭 (Read Amplification)  
- 데이터를 가져오기 위해 여러 테이블을 참조해야 하는 필요에서 발생
     - 예: 메모장에 같은 단어가 여러 페이지에 흩어져 있으면 찾을 때 시간이 더 걸리는 상황

### 쓰기 증폭 (Write Amplification)
- 컴팩션 과정에서 지속적인 재작성으로 인해 발생
    - 예: 같은 데이터를 여러 번 디스크에 기록해야 하는 경우
- 중복 데이터를 제거하려고 자주 compaction할 경우 발생

### 공간 증폭 (Space Amplification)
- 동일한 키와 연관된 여러 레코드를 저장함으로써 발생
    - 예: 사진 파일이 중복 저장되어서 저장 공간을 더 차지하는 경우

<br>

> 중복 데이터를 빨리 제거하면? Write↑, Read/Space↓   
> 중복 데이터를 오래 두면? Write↓, Read/Space↑

## RUM Conjecture
저장 구조에 대한 비용 모델 중 하나로 `읽기`, `업데이트`, `메모리 오버헤드`라는 세 가지 요소를 고려한 가설
RUM의 세 가지 요소:   
- **R** (Read overhead): 데이터를 읽을 때 드는 비용
- **U** (Update overhead): 데이터를 수정/갱신할 때 드는 비용
- **M** (Memory overhead): 메모리를 사용하는 정도

RUM 가설: RUM의 세 요소 중 두 가지를 동시에 줄이면 나머지 한 가지는 **반드시 증가함**   
이상적인 상황이라면? 읽기 비용 최소 + 메모리 오버헤드 최소 + 쓰기 오버헤드 최소 -> 하지만 현실에서는 **불가능**하다!

- B-Tree
    - +) 읽기 성능이 뛰어남 (레코드의 위치를 찾기 쉬움, 범위 검색이 효율적임)
    - -) 쓰기 시 디스크 페이지를 여러 번 수정해야 하고, 나중의 업데이트를 위해 남겨둔 여유 공간이 낭비됨

- LSM Tree
    - +) 쓰기 효율이 높음 (쓰기 시 디스크 탐색이 필요 없음)
    - -) 읽기 시 여러 SSTable을 탐색해야 하므로 읽기 비용이 크고, 데이터가 중복 저장되어 공간 오버헤드가 존재

> RUM 가설은 지연 시간, 구현 복잡도, 하드웨어 특성, 일관성과 복제 등 여러 요소를 고려하지 않으므로 `한계가 있는 모델`이지만 새로운 설계를 선택할 때 `대략적인 방향`을 잡기 위한 기준으로 활용할 수 있음

<br>

# Implementation Details
LSM Tree의 구현 세부사항

## Sorted String Tables (정렬 문자열 테이블, SSTables)
키 순서대로 `정렬`된 `불변` 데이터 파일로 디스크에 저장되는 LSM Tree의 기본 단위

- 구성 요소
    - 인덱스 파일: 키 -> 데이터 위치(`offset`) 매핑 저장
        - **로그** 시간 탐색 구조: B-Tree
        - **상수** 시간 탐색 구조: 해시테이블
            - 해시 테이블을 사용하더라도 범위 스캔 가능 -> 데이터파일이 키 순서대로 정렬되어 있으므로 해시테이블은 첫 번째 키를 찾는 데만 사용, 이후 순차적으로 읽으면 됨
    - 데이터 파일: 실제 `key-value` 레코드 저장, 키 순서로 정렬

- Compaction
    - 데이터가 이미 키 순서로 정렬되어 있어 인덱스가 없어도 순차적으로 읽을 수 있음
    - 병합이 순서를 보존하므로 결과물도 키 순서로 정렬됨
    - **새로 만들어진 SSTable은 즉시** `immutable` **처리 됨**
        - 예: 책을 다 쓰고 난 뒤에는 내용을 수정하지 않고 새 책을 내는 것과 비슷한 개념

> **SASI: SSTable-Attached Secondary Indexes** -> ?🔎   
> LSM Tree의 보조 인덱싱 기법으로 primary key 외의 다른 필드로도 검색이 가능하게 함

## Bloom Filters
지피티 파업으로 일단 여기까지..


