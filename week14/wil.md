# Read, Write, and Space Amplification

### 읽기 증폭 (Read Amplification)  
- 데이터를 가져오기 위해 여러 테이블을 참조해야 하는 필요에서 발생
     - 예: 메모장에 같은 단어가 여러 페이지에 흩어져 있으면 찾을 때 시간이 더 걸리는 상황

### 쓰기 증폭 (Write Amplification)
- 컴팩션 과정에서 지속적인 재작성으로 인해 발생
    - 예: 같은 데이터를 여러 번 디스크에 기록해야 하는 경우
- 중복 데이터를 제거하려고 자주 compaction할 경우 발생

### 공간 증폭 (Space Amplification)
- 동일한 키와 연관된 여러 레코드를 저장함으로써 발생
    - 예: 사진 파일이 중복 저장되어서 저장 공간을 더 차지하는 경우

<br>

> 중복 데이터를 빨리 제거하면? Write↑, Read/Space↓   
> 중복 데이터를 오래 두면? Write↓, Read/Space↑

## RUM Conjecture
저장 구조에 대한 비용 모델 중 하나로 `읽기`, `업데이트`, `메모리 오버헤드`라는 세 가지 요소를 고려한 가설
RUM의 세 가지 요소:   
- **R** (Read overhead): 데이터를 읽을 때 드는 비용
- **U** (Update overhead): 데이터를 수정/갱신할 때 드는 비용
- **M** (Memory overhead): 메모리를 사용하는 정도

RUM 가설: RUM의 세 요소 중 두 가지를 동시에 줄이면 나머지 한 가지는 **반드시 증가함**   
이상적인 상황이라면? 읽기 비용 최소 + 메모리 오버헤드 최소 + 쓰기 오버헤드 최소 -> 하지만 현실에서는 **불가능**하다!

- B-Tree
    - +) 읽기 성능이 뛰어남 (레코드의 위치를 찾기 쉬움, 범위 검색이 효율적임)
    - -) 쓰기 시 디스크 페이지를 여러 번 수정해야 하고, 나중의 업데이트를 위해 남겨둔 여유 공간이 낭비됨

- LSM Tree
    - +) 쓰기 효율이 높음 (쓰기 시 디스크 탐색이 필요 없음)
    - -) 읽기 시 여러 SSTable을 탐색해야 하므로 읽기 비용이 크고, 데이터가 중복 저장되어 공간 오버헤드가 존재

> RUM 가설은 지연 시간, 구현 복잡도, 하드웨어 특성, 일관성과 복제 등 여러 요소를 고려하지 않으므로 `한계가 있는 모델`이지만 새로운 설계를 선택할 때 `대략적인 방향`을 잡기 위한 기준으로 활용할 수 있음

# Implementation Details

