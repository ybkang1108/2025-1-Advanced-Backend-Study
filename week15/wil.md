# Concurrency in LSM Trees

- 테이블 뷰 전환: 여러 스레드가 동시에 데이터를 읽고 쓰는 상황에서 메모리와 디스크의 테이블 구성이 변경되는 문제
- 로그 동기화: 여러 작업이 동시에 WAL(Write-Ahead Log)에 기록하거나 읽을 때의 동기화 문제

## LSM Tree에서 flush 작업 중 반드시 지켜야 할 5가지 규칙
1. 새 메모리 테이블 활성화: 새로운 memtable이 즉시 읽기/쓰기 작업을 받을 수 있어야 한다
2. 기존 테이블 가시성 유지: 플러시 중인 memtable은 디스크 저장이 완료될 때까지 읽기 요청에 응답해야 한다
3. 디스크 저장 완료: 메모리의 데이터가 안전하게 디스크에 기록되어야 한다
4. 원자적 전환: 메모리 테이블 제거와 디스크 테이블 활성화가 동시에 일어나야 한다
5. 로그 정리: 해당 메모리 테이블과 관련된 WAL 세그먼트를 안전하게 삭제해야 한다

> Apache Cassandra는 `Operation Order Barriers`를 사용하여 동시성 문제를 해결한다
> <br><br>
> **작업 순서 장벽 (Operation Order Barriers)** -> 
> 플러시가 시작되기 전에 진행 중인 모든 쓰기 작업의 완료를 기다림 = `소비자`는 모든 `생산자`가 작업을 완료할 때까지 기다려야 함
> - 생산자: 데이터를 memtable에 쓰는 여러 스레드들
> - 소비자: memtable을 디스크로 플러시하는 프로세스
> ---
> 작동 원리:
> 1. 여러 쓰기 작업이 동시에 memtable에 데이터를 입력
> 2. 플러시가 필요한 시점이 되면 **Barrier** 설치
> 3. Barrier 이전에 시작된 모든 쓰기 작업의 완료를 기다림
> 4. 모든 작업이 완료되면 안전하게 플러시 시작

## LSM Tree에서 발생하는 3가지 핵심 동기화 지점

1. **Memtable Switch 멤테이블 전환**: 새로운 쓰기는 새 memtable로 이동
 
2. **Flush Finalization 플러시 완료**: 기존 memtable 내용을 디스크 SSTable로 완전 이전

3. **Write-Ahead Log Truncation 선행 기록 로그 절단**: 불필요한 WAL 부분 정리

### 3가지 동기화 지점이 잘못 처리되면 어떻게 될까?
- 데이터 손실 문제 -> 잘못된 쓰기가 지속됨
    - 예: Memtable Switch가 제대로 이루어지지 않아 기존 memtable에 계속 쓰기가 발생한다면?
        - 해당 영역은 이미 완료된 것으로 간주되어 더 이상 디스크에 반영되지 않음
        - 새로 추가된 데이터가 *영구적으로 손실*된다!

- 불완전한 읽기 결과 -> 너무 빠른 memtable 제거
    - 예: 디스크 테이블이 완전히 준비되기 이전에 memtable을 읽기에서 제외한다면?
        - 읽기 요청 시 일부 데이터를 찾을 수 없어 *부분적인 결과만 반환*하게 된다!

## Compaction 과정에서의 동기화 문제 
compaction: 기존 디스크 테이블들이 폐기되고 컴팩션된 버전이 추가됨 -> 공간 효율성, 읽기 성능, 유지보수 측면에서 좋음
> 플러시: 메모리 ↔ 디스크 간의 전환   
> 컴팩션: 디스크 ↔ 디스크 간의 교체
- 새로운 테이블이 완전히 작성되고 대체될 때까지 읽기 가능한 상태로 남아있어야 함
- 같은 테이블이 여러 컴팩션 작업에 동시에 참여하는 것은 피해야 함

> B-Tree와 LSM Tree에서 로그 관리   
> - **B-Tree**   
> 더티 페이지(메모리에서 수정되었지만 아직 디스크에 반영되지 않은 페이지)가 디스크로 완전히 저장된 후에만 해당 로그를 삭제할 수 있음
> - **LSM Tree**
> 쓰기 작업들이 메모리의 memtable에 임시 저장되고 memtable 플러시 완료 후에만 해당 WAL 세그먼트를 삭제할 수 있음
> <br><br>
> *플러시가 완료되기 전에 로그 세그먼트가 폐기되고 노드가 충돌되면 로그 내용을 재생할 수 없으므로 데이터를 복구할 수 없게 된다!*

# Log Stacking


